// This file is property of Žiga Osolin (ziga.osolin@gmail.com)
#pragma once
#include "LinearAlgebra.h"

#include <vector>

// Constants.
const Scalar PI = (Scalar)3.141592653589793238462643383279;

// Configuration data.
extern Scalar IL_Epsilon;						  //< Epsilon for numerical comparison (abs(x-y)<epsilon <===> x==y)
extern Scalar IL_MinimumNextIntersectionDistance; //< Default minimum distance for next intersection.


// A colour type, final data in image.
typedef Vec3 Colour;
// A scalar for each of wavelength. 
// (May use more wavelength if you define VecN and appropriate operations)
typedef Vec3 ColourScalar;

struct RandomGenerator;

// Describes the traveling of ray when going through an volume.
// Remarks: NULL medium is the same as noninteracting medium with indexOfRefraction=1.
class IMedium
{
protected:
	// Index of refraction for medium per wavelength.
	// Rays have to be split per colour if it is not colour invariant.
	ColourScalar indexOfRefraction;
public:
	IMedium() : indexOfRefraction(1,1,1) {}
	IMedium(const ColourScalar& index) : indexOfRefraction(index) {}

	const ColourScalar& GetIndexOfRefraction() { return indexOfRefraction; }
	bool IsIndexColourInvariant() { return indexOfRefraction.x == indexOfRefraction.y && indexOfRefraction.y == indexOfRefraction.z; }
	Scalar GetInvariantIndex() { return indexOfRefraction.x; }

	// Uses weight as scaling factor in either case (for example to simulate absorption).
	// p1 and p2 are hits with surfaces of next ray, n1 is normal at point 1. If new ray is created,
	// return true (p2 will be discarded) and set position and new direction. Else return false and
	// ray intensity will be multiplied by weight and ray will be processed against surface.
	// Remarks: default implementation is uniform hemisphere sampling.
	virtual bool SampleScattering(const Vec3& p1, const Vec3& n1, const Vec3& p2, RandomGenerator* random,
		ColourScalar& weight, Vec3& positionOfScattering, Vec3& newDirection)=0;
};

// A ray type.
struct Ray
{
	Vec3 origin;
	Vec3 direction;
	IMedium* medium;	//< The medium complete ray resides in

	Ray() : medium(0){}
	Ray(const Vec3& o, const Vec3& dir) : origin(o), direction(dir), medium(0) {}
};

class IGeometry;
struct Material;
class ISurfaceLight;

// An intersection result.
struct IntersectResult
{
	// Distance from start of ray to intersection.
	Scalar distance;
	// Normal on surface of intersection.
	Vec3 normal;
	// The material at intersection.
	Material* material;
	// Additional geometry specific data needed by material; 
	// texture coordinates of intersection etc. This can be generated by geometry
	// at intersection.
	void* materialData;

	IntersectResult() : distance(std::numeric_limits<Scalar>::max()) {}
};

// A light, must be able to sample photons. Poton map can be generated this way.
class ILight
{
public:
	// Samples light, returns photon energy.
	virtual Vec3 Sample(int indexOfPhoton, int sampleCount, RandomGenerator* random, Vec3& position, Vec3& direction)=0;

	// Obtains medium light resides in (to support lights inside water etc.)
	virtual IMedium* GetLightMedium() { return 0; }
};

// A lightsource, attached to surface.
class ISurfaceLight : public ILight
{
public:
	// Computes radiance per colour channel of (surface) light.
	virtual ColourScalar Radiance(const Vec3& surfacePosition, const Vec3& direction, const Vec3& normal)=0;
};

struct Photon;

// Singular light sources are treated seperately because they are really small and
// cannot be reached with normal integration (not attached to geometry).
class ISingularLight : public ILight
{
public:
	virtual ColourScalar Radiance(const Vec3& surfacePoint, Vec3& towardsLightDirection, IGeometry* geometry)=0;
};

// The sampling needed by material, flag like.
enum SamplingType
{
	Singular = 1,	   		        //< Useful for materials where you don't want to spawn secondary rays. Sample is never called.
	MultipleSample = 2,			    //< Multiple samples to estimate integral, with no direct lights.
	SingularAndMultipleSample = 1|2,//< Most common, direct lightning and integral estimate.
	Caustics = 4					//< This type of material must be traced for caustics until first non-caustics hit.
};

// Describes behaviour of ray when it hits the surface.
class IBSDF
{
public:
	// Calculates BSDF given normal, worldPosition and in/out direction. In and out directions are based
	// on light perspective, out is towards camera (new surface), in is towards lightsource (indirect lightsource).
	// Remarks: for any physical PSDF, out and in direction can be interchanged.
	// Remarks: outside medium is always where normal vector points.
	virtual ColourScalar BSDF(const Vec3& worldPosition, const Vec3& normal, 
            const Vec3& inDirection, const Vec3& outDirection, void* materialData, 
			IMedium* insideMedium, IMedium* outsideMedium) = 0;

	// Returns SamplingType.
	virtual SamplingType GetSamplingType(const Vec3& cameraDirection, const Vec3& normal) { return SingularAndMultipleSample; }

	// Returns number of samples. This value is usually std::numerics<int>::max().
	virtual int GetMaxNumberOfSamples(const Vec3& cameraDirection, const Vec3& normal) { return std::numeric_limits<int>::max(); }
	
	// Samples based on distribution plus cosine factor between genDirection and normal.
	// Remarks: cameraDirection is towards camera (for raytracing) and towards light (for photon tracing).
	// Remarks: if sampling scalars are added together, we obtain the estimate. This means normalization 
	// (2PI/numberOfSamples - only reflection rays, 4PI/numberOfSamples - all possible reflections) is in this method.
	// Remarks: ray index may be sometimes needed because first ray is for example reflection and others are
	// scaterrings.
	virtual ColourScalar Sample(int rayIndex, int numberOfSamples, const Vec3& worldPosition, const Vec3& normal, 
		const Vec3& cameraDirection, RandomGenerator* random, void* materialData,
		IMedium* insideMedium, IMedium* outsideMedium, Vec3& genDirection);

	// Helpers

	// Generates (for same normal always the same) tangent and binormal.
	void GenerateTangentBinormal(const Vec3& normal, Vec3& tangent, Vec3& binormal);

};

// Represents an image in RGB format.
class Image
{
	Colour* data;
	int width, height;
public:
	Colour* GetData() { return data; }
	int GetWidth() { return width; }
	int GetHeight() { return height; }

	Image(int w, int h) : width(w), height(h) 
	{ 
		data = new Colour[w*h];
		for(int i = 0; i < w*h; i++)
			data[i] = Vec3(0,0,0);
	}
	~Image() { delete [] data; data = 0; }

	// Maximum value of either RGB components of image.
	Scalar Max();
	// Normalizes using scalar.
	void Multiply(Scalar scalar);
	// Transforms image by function.
	void Transform(Colour (*mapFunction)(const Colour& c));
	// Transforms in eye response coordinates (power law - as sqrt).
	void EyeResponseTransform1();
	// Normalize by max component.
	void Normalize() { Scalar s = Max(); Multiply(1/s); }
	// Saves image as RGB. Must first be normalized to range [0,1]; 
	// all values above 1 are clamped to 1.
	bool SaveAsBmp(const char* filename);
	// Saves image as width height numbers
	bool SaveAsRaw(const char* filename);

};


// Complete description of interaction of light with surface.
struct Material
{
	IBSDF*			bsdf;		  //< Hit surface reflection
	ISurfaceLight*	surfaceLight; //< Surface light source
	IMedium*		insideMedium; //< Describes medium inside object.

	Material() : bsdf(0), insideMedium(0), surfaceLight(0) {}
	Material(IBSDF* bsdf) { this->bsdf = bsdf; surfaceLight = 0; insideMedium = 0; }
};

// Describes geometry of enviorment.
class IGeometry
{
public:
	// Intersects geometry versus enviorment. This call must update result when
	// better hit than the one in result is found (closer). 
	virtual void Intersect(const Ray& ray, IntersectResult& result)=0;

	// A shadow ray from point 1 to point 2, if any intersection found, result is true.
	bool IsInShadow(const Vec3& p1, const Vec3& p2);
};

// Samples surface of geometry uniformly, used by lightning.
class ISurfaceSampler
{
public:
	virtual Vec3 Sample(int sampleIndex, int sampleCount, RandomGenerator* generator, Vec3& normal)=0;
};

// A pinhole camera.
class Camera
{
public:
	Vec3 position;
	Vec3 direction;
	Image image;
	Scalar FOV;
	IMedium* startingMedium;

	Camera(int imageX, int imageY, Scalar fov) : image(imageX, imageY), direction(0,0,-1), 
		FOV(fov), position(0,0,0), startingMedium(0) {}
	~Camera() { }

	// Obtains pixel direction. If random is non-null, direction is randomized
	// over all pixel solid angle.
	Vec3 GetPixelDirection(int x, int y, RandomGenerator* random);

	// Obtains pixel index from input direction.
	bool GetPixelFromDirection(const Vec3& direction, int& x, int& y);

	// Obtains image where data is rendered.
	Image* GetAssociatedImage() { return &image; }
};

class PhotonMap;

// Abstract image renderer.
class IRenderer
{
public:
	virtual void Render(Camera* camera, IGeometry* sceneGeometry, IGeometry* singularLightGeometry,
		std::vector<ISingularLight*> singularLights, PhotonMap* globalMap, PhotonMap* causticsMap)=0;
};

// A Numerical Recipes random number generator.
struct RandomGenerator
{
	BigUInt u, v, w;
	RandomGenerator(BigUInt j): v(4101842887655102017LL), w(1) 
	{
		u = j ^ v; NextInt64();
		v = u; NextInt64();
		w = v; NextInt64();
	}

	// Generates random integer.
	inline BigUInt NextInt64()
	{
		u = u * 2862933555777941757LL + 704602925438635308LL;
		v ^= v >> 17; v ^= v << 31; v ^= v >> 8;
		w = 4294957665U*(w & 0xFFFFFFFF) + (w >> 32);
		BigUInt x = u ^(u << 21); x ^= x >> 35; x ^= x << 4;
		return (x + v) ^ w;
	}

	// Generates random number in range [0,1).
	inline Scalar NextUniform()
	{
		return (Scalar) (5.42101086242752217e-20 * NextInt64());
	}

	// Generates random direction.
	Vec3 NextDirection();

	// Generates random hemisphere direction.
	Vec3 NextHemisphereDirection(const Vec3& normal);

};



